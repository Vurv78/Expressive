-- ES -> Lua Transpiler
local ELib = require("expressive/library")

local Ast = ELib.Ast
local Parser = ELib.Parser
local Tokenizer = ELib.Tokenizer

local TOKEN_KINDS = Tokenizer.KINDS
local NODE_KINDS = Parser.KINDS

local function fmt(...)
	return string.format(...)
end

---@class Transpiler
---@field current number
---@field nodes table<number, Node> # Mini-ASTs or the global ast, that are from code blocks
---@field ast table<number, Node> # The AST generated by the parser.
local Transpiler = {}
Transpiler.__index = Transpiler

function Transpiler.new()
	return setmetatable({}, Transpiler)
end

local VarModifications = {
	["+="] = function(self, name, expr2)
		return fmt("%s = %s + %s", name, name, self:transpile(expr2))
	end,
	["-="] = function(self, name, expr2)
		return fmt("%s = %s - %s", name, name, self:transpile(expr2))
	end,
	["*="] = function(self, name, expr2)
		return fmt("%s = %s * %s", name, name, self:transpile(expr2))
	end,
	["/="] = function(self, name, expr2)
		return fmt("%s = %s / %s", name, name, self:transpile(expr2))
	end,
	["%="] = function(self, name, expr2)
		return fmt("%s = %s %% %s", name, name, self:transpile(expr2))
	end,
	["^="] = function(self, name, expr2)
		return fmt("%s = %s ^ %s", name, name, self:transpile(expr2))
	end,
	["="] = function(self, name, expr2)
		return fmt("%s = %s", name, self:transpile(expr2))
	end,
	["++"] = function(self, name, expr2)
		return fmt("%s = %s + 1", name, name)
	end,
	["--"] = function(self, name, expr2)
		return fmt("%s = %s - 1", name, name)
	end
}

local Transpilers = {
	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Block] = function(self, node)
		local block = unpack(node.data)
		self:pushScope()
		local res = self:transpileAst(block, true)
		self:popScope()
		return fmt("(function()\n\t%s\nend)()", res)
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.VarDeclare] = function(self, node)
		local kw, name, type, expr = unpack(node.data)
		if kw == "var" then
			return fmt("%s = %s", name, self:transpile(expr))
		else
			return fmt("local %s = %s", name, self:transpile(expr))
		end
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.VarModify] = function(self, node)
		local name, how, expr2 = unpack(node.data)
		return VarModifications[how](self, name, expr2)
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Variable] = function(self, node)
		local name = unpack(node.data)
		return name
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.ArithmeticOps] = function(self, node)
		local op, expr1, expr2 = unpack(node.data)
		return fmt("%s %s %s", self:transpile(expr1), op, self:transpile(expr2))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Array] = function(self, node)
		local args = unpack(node.data)
		local res = {}
		for i, v in ipairs(args) do
			res[i] = self:transpile(v)
		end
		return fmt("{%s}", table.concat(res, ", "))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.CallExpr] = function(self, node)
		local fn_expr, args = unpack(node.data)
		local res = {}
		for i, v in ipairs(args) do
			res[i] = self:transpile(v)
		end
		return fmt("%s(%s)", self:transpile(fn_expr), table.concat(res, ", "))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Index] = function(self, node)
		---@type string
		local method = node.data[1]
		---@type Node
		local tbl = node.data[2]
		---@type Token|Node
		local key  = node.data[3] -- A token if it's a literal (x.0 or x.y), a node if it's a variable (x[y])

		if method == "[]" then
			-- Runtime indices
			return fmt("%s[%s]", self:transpile(tbl), self:transpile(key))
		elseif method == "." then
			-- Static indices
			if Parser.isToken(key, TOKEN_KINDS.Integer) then
				return fmt("%s[%i]" , self:transpile(tbl), key.value)
			else
				return fmt("%s.%s", self:transpile(tbl), key.raw)
			end
		end
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.ComparisonOps] = function(self, node)
		local op, expr1, expr2 = unpack(node.data)
		if op == "!=" then op = "~=" end
		return fmt("%s %s %s", self:transpile(expr1), op, self:transpile(expr2))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.GroupedExpr] = function(self, node)
		local expr = unpack(node.data)
		return fmt("(%s)", self:transpile(expr))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Escape] = function(self, node)
		local method, ret = unpack(node.data)
		if method == "return" then
			return fmt("return %s", self:transpile(ret))
		else
			-- continue or break
			return method
		end
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.If] = function(self, node)
		local cond, block = unpack(node.data)

		local next = self:peek()
		if next then
			if next.kind == NODE_KINDS.Else or next.kind == NODE_KINDS.Elseif then
				return fmt("if %s then %s", self:transpile(cond), self:transpileAst(block))
			end
		end

		return fmt("if %s then %s end", self:transpile(cond), self:transpile(block))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Elseif] = function(self, node)
		local cond, block = unpack(node.data)
		local next = self:peek()
		if next then
			if next.kind == NODE_KINDS.Else or next.kind == NODE_KINDS.Elseif then
				return fmt("elseif %s then %s", self:transpile(cond), self:transpileAst(block))
			end
		end

		return fmt("elseif %s then %s end", self:transpile(cond), self:transpileAst(block))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Else] = function(self, node)
		local block = unpack(node.data)
		return fmt("else %s end", self:transpileAst(block))
	end,

	---@param self Tokenizer
	---@param node Node
	[NODE_KINDS.Literal] = function(self, node)
		---@type "number"|"string"|"boolean"|"null"
		local type = node.data[1]

		if type == "number" then
			return tostring(node.data[2])
		elseif type == "string" then
			return fmt("%q", node.data[2])
		elseif type == "boolean" then
			return node.data[2] and "true" or "false"
		elseif type == "null" then
			return "nil"
		end
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Function] = function(self, node)
		-- TODO: 'name' here will be an expr in the future for lambdas.
		local name, args, block = unpack(node.data)

		-- Array of { [1] = name, [2] = type_name }
		---@type table<number, string>
		local argnames = {}
		for k, arg in ipairs(args) do
			argnames[k] = arg[1]
		end
		return fmt("local function %s(%s)\n\t%s\nend", name, table.concat(argnames, ", "), self:transpileAst(block, true))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.Lambda] = function(self, node)
		local args, block = unpack(node.data)

		-- Array of { [1] = name, [2] = type_name }
		---@type table<number, string>
		local argnames = {}
		for k, arg in ipairs(args) do
			args[k] = arg[1]
		end
		return fmt("function(%s)\n\t%s\nend", table.concat(args, ", "), self:transpileAst(block, true))
	end,

	---@param self Transpiler
	---@param node Node
	[NODE_KINDS.For] = function(self, node)
		local kw, varname, start, cond, step, block = unpack(node.data)
		--[[
			$kw $varname = $start
			while $cond do
				$block
				$step
			end
		]]
		self:pushScope()
			block = self:transpileAst(block, true)
		self:popScope()

		return fmt(
			"local %s = %s\nwhile %s do\n\t%s\n\t%s\nend",
			varname,
			self:transpile(start),
			self:transpile(cond),
			block,
			self:transpile(step)
		)
	end,

	[NODE_KINDS.Try] = function(self, node)
		local try_block, catch_var, catch_ty, catch_block = unpack(node.data)
		--[[
			xpcall(function()
				$try_block
			end, function($catch_var)
				$catch_block
			end)
		]]
		self:pushScope()
			try_block = self:transpileAst(try_block, true)
		self:popScope()

		self:pushScope()
			catch_block = self:transpileAst(catch_block, true)
		self:popScope()

		return fmt(
			"xpcall(function()\n\t%s\nend, function(%s)\n\t%s\nend)",
			try_block,
			catch_var,
			catch_block
		)
	end
}

function Transpiler:pushScope()
	-- todo
end

function Transpiler:popScope()
	-- todo
end

---@return Node?
function Transpiler:peek()
	return self.nodes[self.current + 1]
end

---@param node Node
---@return string?
function Transpiler:transpile(node)
	local handler = Transpilers[node.kind]
	if handler then
		return handler(self, node)
	end
	ErrorNoHalt("ES: !!! Unimplemented Transpile target: ", Parser.KINDS_INV[node.kind], "\n")
	return ""
end

---@param ast table<number, Node>
---@param indent boolean
---@return string
function Transpiler:transpileAst(ast, indent)
	local ret = {}
	if not ast then return "" end -- Empty block

	self.nodes = ast
	for i, node in ipairs(ast) do
		self.current = i
		if indent then
			ret[i] = string.gsub(self:transpile(node), "\n", "\n\t")
		else
			ret[i] = self:transpile(node)
		end
	end
	return table.concat(ret, indent and "\n\t" or "\n")
end

--- Transpiles ES code into Lua.
--- Get the ast from the [Analyzer].
---@param ctx Context
---@param ast table<number, Node>
---@return string
function Transpiler:process(ctx, ast)
	self.ctx = ctx
	self.ast = ast
	return self:transpileAst(ast)
end

ELib.Transpiler = Transpiler

return Transpiler